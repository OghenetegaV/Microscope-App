<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Microscope + Measurement (Camera + Freeze Fixed)</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  body{background:linear-gradient(180deg,#071024 0%,#07192b 100%);color:#e6eef6;display:flex;align-items:center;justify-content:center;padding:12px;}
  .app{width:100%;max-width:1100px;background:var(--card);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6);}
  header{display:flex;align-items:center;gap:12px}
  h1{font-size:18px;margin:0}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px;margin-top:12px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .viewer{background:#0b1220;border-radius:8px;position:relative;overflow:hidden;min-height:420px}
  video,canvas#frozenFrame{width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;}
  canvas.overlay{position:absolute;left:0;top:0;right:0;bottom:0;width:100%;height:100%;}
  .controls{display:flex;flex-direction:column;gap:8px;padding:8px}
  .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
  .btn{background:var(--accent);color:#062024;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .measure-list{max-height:200px;overflow:auto;padding:6px;font-size:13px;border-radius:6px;background:rgba(0,0,0,0.15)}
  .small{font-size:12px;color:var(--muted)}
  footer{font-size:12px;color:var(--muted);margin-top:8px}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Microscope + Measurement — Image Analysis Tool</h1>
    <div style="margin-left:auto" class="small">Freeze for stable calibration</div>
  </header>

  <div class="grid">
    <div>
      <div class="viewer">
        <video id="video" autoplay playsinline></video>
        <canvas id="frozenFrame"></canvas>
        <canvas id="overlay" class="overlay"></canvas>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <button id="freezeBtn" class="btn">Freeze</button>
        <button id="captureBtn" class="btn">Capture</button>
        <button id="clearBtn" class="btn secondary">Clear</button>
        <button id="exportBtn" class="btn secondary">Export CSV</button>
      </div>

      <div class="panel" style="margin-top:8px">
        <div class="small">Digital Zoom</div>
        <input id="zoomRange" type="range" min="1" max="64" step="0.01" value="1">
        <div class="small">Current Zoom: <span id="zoomDisplay">1×</span></div>
      </div>
    </div>

    <aside class="controls">
      <div class="panel">
        <div class="small"><strong>Calibration</strong></div>
        <div class="small" style="margin-top:6px">Click two points on a known-length reference, then enter distance (mm).</div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="calModeBtn" class="btn secondary">Enter Calibrate Mode</button>
          <button id="resetCalBtn" class="btn secondary">Reset</button>
        </div>
        <div style="margin-top:8px">
          <label class="small">Pixels per mm:</label>
          <div id="pxPerMm" style="font-weight:700">—</div>
          <label class="small">True Magnification:</label>
          <div id="trueMag" style="font-weight:700">—</div>
        </div>
      </div>

      <div class="panel">
        <div class="small"><strong>Measurement</strong></div>
        <div class="small" style="margin-top:6px">Click two points across crack to measure width.</div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="measureModeBtn" class="btn">Measure</button>
          <button id="saveMeasureBtn" class="btn secondary">Save</button>
        </div>
        <div style="margin-top:8px">
          <label class="small">Saved Measurements (mm)</label>
          <div id="measureList" class="measure-list"></div>
        </div>
      </div>

      <footer>v1.5 — Camera stable, freeze aspect ratio fixed.</footer>
    </aside>
  </div>
</div>

<script>
(async function(){
  const video=document.getElementById('video'),
        overlay=document.getElementById('overlay'),
        frozenCanvas=document.getElementById('frozenFrame'),
        ctx=overlay.getContext('2d'),
        frozenCtx=frozenCanvas.getContext('2d');

  const freezeBtn=document.getElementById('freezeBtn'),
        zoomRange=document.getElementById('zoomRange'),
        zoomDisplay=document.getElementById('zoomDisplay'),
        trueMagEl=document.getElementById('trueMag'),
        pxPerMmEl=document.getElementById('pxPerMm'),
        calModeBtn=document.getElementById('calModeBtn'),
        resetCalBtn=document.getElementById('resetCalBtn'),
        measureModeBtn=document.getElementById('measureModeBtn'),
        saveMeasureBtn=document.getElementById('saveMeasureBtn'),
        clearBtn=document.getElementById('clearBtn'),
        captureBtn=document.getElementById('captureBtn'),
        exportBtn=document.getElementById('exportBtn'),
        measureListEl=document.getElementById('measureList');

  let stream=null,isFrozen=false,currentMode=null,calibration={pixels:null,mm:null,pxPerMm:null},points=[],saved=[],trueMag=1;

  function fitCanvas(){
    const w=overlay.clientWidth,h=overlay.clientHeight;
    [overlay,frozenCanvas].forEach(c=>{c.width=w;c.height=h;});
  }

  async function startCamera(){
    try{
      stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
      video.srcObject=stream;
      video.addEventListener('loadedmetadata',()=>{
        fitCanvas();
        video.play();
      });
    }catch(e){
      alert('Camera access error: '+e.message);
    }
  }

  await startCamera();

  // Freeze logic — now safe
// Replace your existing freezeBtn.onclick handler with this version
freezeBtn.onclick = () => {
  if (!isFrozen) {
    fitCanvas(); // keep canvas sizes matched
    // Compute how the <video> is being cropped inside the element box
    const vRatio = video.videoWidth / video.videoHeight;
    const boxRatio = video.clientWidth / video.clientHeight;
    let sx, sy, sw, sh;

    if (vRatio > boxRatio) {
      // video is wider → crop horizontally
      sh = video.videoHeight;
      sw = sh * boxRatio;
      sx = (video.videoWidth - sw) / 2;
      sy = 0;
    } else {
      // video is taller → crop vertically
      sw = video.videoWidth;
      sh = sw / boxRatio;
      sx = 0;
      sy = (video.videoHeight - sh) / 2;
    }

    // Clear and draw exactly the visible portion
    frozenCtx.clearRect(0, 0, frozenCanvas.width, frozenCanvas.height);
    frozenCtx.drawImage(
      video,
      sx, sy, sw, sh,                // crop region from camera frame
      0, 0, frozenCanvas.width, frozenCanvas.height // draw region size
    );

    frozenCanvas.style.display = 'block';
    video.style.display = 'none';
    freezeBtn.textContent = 'Unfreeze';
    isFrozen = true;
  } else {
    frozenCanvas.style.display = 'none';
    video.style.display = 'block';
    freezeBtn.textContent = 'Freeze';
    isFrozen = false;
  }
};


  zoomRange.addEventListener('input',()=>{
    const z=Number(zoomRange.value);
    video.style.transform=`scale(${z})`;
    frozenCanvas.style.transform=`scale(${z})`;
    zoomDisplay.textContent=z.toFixed(1)+'×';
    updateMagnification();
  });

  function updateMagnification(){
    if(!calibration.pxPerMm){trueMagEl.textContent='—';trueMag=1;return;}
    const screenPPI=window.devicePixelRatio*96;
    const screenPxPerMm=screenPPI/25.4;
    trueMag=(calibration.pxPerMm/screenPxPerMm)*Number(zoomRange.value);
    trueMagEl.textContent=trueMag.toFixed(1)+'×';
  }

  function clientToCanvas(e){
    const r=overlay.getBoundingClientRect();
    const x=((e.touches?e.touches[0].clientX:e.clientX)-r.left)*(overlay.width/r.width);
    const y=((e.touches?e.touches[0].clientY:e.clientY)-r.top)*(overlay.height/r.height);
    return {x,y};
  }

  let dragging=null;
  overlay.addEventListener('pointerdown',e=>{
    overlay.setPointerCapture(e.pointerId);
    const p=clientToCanvas(e);
    for(const pt of points){if(Math.hypot(pt.x-p.x,pt.y-p.y)<8){dragging=pt;return;}}
    if(currentMode==='calibrate'){
      points.push({x:p.x,y:p.y,type:'cal'});
      const c=points.filter(pt=>pt.type==='cal');
      if(c.length===2){
        const dx=c[0].x-c[1].x,dy=c[0].y-c[1].y,pix=Math.hypot(dx,dy);
        const real=prompt('Enter real distance (mm):');
        if(real&&!isNaN(real)&&Number(real)>0){
          calibration={pixels:pix,mm:Number(real),pxPerMm:pix/Number(real)};
          pxPerMmEl.textContent=calibration.pxPerMm.toFixed(3)+' px/mm';
          updateMagnification();
        }else alert('Invalid input');
        currentMode=null;calModeBtn.textContent='Enter Calibrate Mode';
      }
    }else if(currentMode==='measure'){
      points.push({x:p.x,y:p.y,type:'meas'});
      const m=points.filter(pt=>pt.type==='meas');
      if(m.length===2){
        const dx=m[0].x-m[1].x,dy=m[0].y-m[1].y,pix=Math.hypot(dx,dy);
        const mm=calibration.pxPerMm?pix/calibration.pxPerMm:null;
        alert('Measured: '+(mm?mm.toFixed(3)+' mm':'Uncalibrated'));
        currentMode=null;measureModeBtn.textContent='Measure';
      }
    }
    draw();
  });
  overlay.addEventListener('pointermove',e=>{if(!dragging)return;const p=clientToCanvas(e);dragging.x=p.x;dragging.y=p.y;draw();});
  overlay.addEventListener('pointerup',()=>dragging=null);

  calModeBtn.onclick=()=>{currentMode=currentMode==='calibrate'?null:'calibrate';calModeBtn.textContent=currentMode?'Exit Calibrate Mode':'Enter Calibrate Mode';};
  measureModeBtn.onclick=()=>{currentMode=currentMode==='measure'?null:'measure';measureModeBtn.textContent=currentMode?'Exit Measure Mode':'Measure';};
  resetCalBtn.onclick=()=>{calibration={pixels:null,mm:null,pxPerMm:null};pxPerMmEl.textContent='—';trueMagEl.textContent='—';points=points.filter(p=>p.type!=='cal');draw();};
  saveMeasureBtn.onclick=()=>{
    const m=points.filter(p=>p.type==='meas');
    if(m.length<2)return alert('Place two points');
    if(!calibration.pxPerMm)return alert('Calibrate first');
    const dx=m[0].x-m[1].x,dy=m[0].y-m[1].y,pix=Math.hypot(dx,dy),mm=pix/calibration.pxPerMm;
    saved.push({time:new Date().toISOString(),mm,mag:trueMag});
    updateList();
  };
  clearBtn.onclick=()=>{points=[];draw();};
  captureBtn.onclick=()=>{
    const c=document.createElement('canvas');c.width=overlay.width;c.height=overlay.height;
    const cx=c.getContext('2d');
    if(isFrozen)cx.drawImage(frozenCanvas,0,0,c.width,c.height);else cx.drawImage(video,0,0,c.width,c.height);
    cx.drawImage(overlay,0,0);
    const img=c.toDataURL('image/png');const w=window.open();if(w)w.document.write('<img src="'+img+'" style="max-width:100%">');
  };
  exportBtn.onclick=()=>{
    if(!saved.length)return alert('No data');
    const csv='timestamp,mm,magnification\n'+saved.map(r=>`${r.time},${r.mm.toFixed(4)},${r.mag.toFixed(1)}`).join('\n');
    const blob=new Blob([csv],{type:'text/csv'});const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='measurements.csv';a.click();
  };

  function updateList(){
    measureListEl.innerHTML='';
    saved.forEach((m,i)=>{
      const d=document.createElement('div');
      d.textContent=`${i+1}. ${m.mm.toFixed(3)} mm @ ${m.mag.toFixed(1)}× — ${m.time}`;
      measureListEl.appendChild(d);
    });
  }

  function draw(){
    ctx.clearRect(0,0,overlay.width,overlay.height);
    for(let i=0;i<points.length;i++){
      const p=points[i];
      ctx.fillStyle=p.type==='cal'?'#ffb020':'#06b6d4';
      ctx.beginPath();ctx.arc(p.x,p.y,2,0,Math.PI*2);ctx.fill();
      if(i%2===1&&points[i-1]){
        const a=points[i-1],b=points[i];const dx=a.x-b.x,dy=a.y-b.y,pix=Math.hypot(dx,dy);
        const mm=calibration.pxPerMm?pix/calibration.pxPerMm:null;
        ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.lineTo(b.x,b.y);
        ctx.strokeStyle=p.type==='cal'?'#ffb020':'#06b6d4';ctx.lineWidth=2;ctx.stroke();
        ctx.fillStyle='#e6eef6';ctx.font='14px sans-serif';
        ctx.fillText(mm?mm.toFixed(3)+' mm':Math.round(pix)+' px',(a.x+b.x)/2+8,(a.y+b.y)/2-8);
      }
    }
  }
  requestAnimationFrame(function loop(){draw();requestAnimationFrame(loop);});
})();
</script>
</body>
</html>
