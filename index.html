<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Microscope + Measurement (v2.1 — 1mm scale)</title>
<style>
:root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#071024 0%,#07192b 100%);color:#e6eef6}
.app{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;min-height:100vh;width:100%;max-width:1000px;margin:0 auto;padding:10px;box-sizing:border-box;background:var(--card);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
header{display:flex;align-items:center;gap:12px;width:100%}
h1{font-size:18px;margin:0}
.grid{display:grid;grid-template-columns:1fr 360px;gap:12px;margin-top:12px;width:100%}
@media (max-width:900px){.grid{grid-template-columns:1fr}}
.viewer{position:relative;width:100%;background:#000;border-radius:10px;overflow:hidden;aspect-ratio:4/3;max-height:80vh}
video,canvas.overlay,canvas#frozenFrame{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:contain}
video{background:none;opacity:1;z-index:0}
canvas.overlay,canvas#frozenFrame{background:transparent !important;z-index:1}
.controls{display:flex;flex-direction:column;gap:10px;width:100%;margin-top:10px}
.panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px}
.btn{background:var(--accent);color:#062024;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
.measure-list{max-height:200px;overflow:auto;padding:6px;font-size:13px;border-radius:6px;background:rgba(0,0,0,0.15)}
.small{font-size:12px;color:var(--muted)}
.footer{font-size:12px;color:var(--muted);margin-top:8px}
.measure-readout{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:6px;font-family:monospace;color:#fff;z-index:2}
@media (max-width:768px){.viewer{width:100%;height:60vh;aspect-ratio:auto}.app{padding:5px}.controls{gap:6px}}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Microscope + Measurement — Image Analysis Tool</h1>
    <div style="margin-left:auto" class="small">Freeze for stable calibration</div>
  </header>

  <div class="grid">
    <div>
      <div class="viewer">
        <div class="measure-readout" id="liveReadout">No measurement</div>
        <video id="video" autoplay playsinline></video>
        <canvas id="frozenFrame"></canvas>
        <canvas id="overlay" class="overlay"></canvas>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <button id="freezeBtn" class="btn">Freeze</button>
        <button id="captureBtn" class="btn">Capture</button>
        <button id="clearBtn" class="btn secondary">Clear</button>
        <button id="exportBtn" class="btn secondary">Export CSV</button>
      </div>

      <div class="panel" style="margin-top:8px">
        <div class="small">Digital Zoom</div>
        <div style="display:flex;align-items:center;gap:6px;">
          <button id="zoomOutBtn" class="btn secondary" style="width:36px;">−</button>
          <input id="zoomRange" type="range" min="1" max="64" step="0.1" value="1" style="flex:1;">
          <button id="zoomInBtn" class="btn secondary" style="width:36px;">+</button>
        </div>
        <div class="small">Current Zoom: <span id="zoomDisplay">1×</span></div>
      </div>
    </div>

    <aside class="controls">
      <div class="panel">
        <div class="small"><strong>Calibration</strong></div>
        <div class="small" style="margin-top:6px">Click two points on a known-length reference (e.g. 10 mm), then enter distance (mm).</div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="calModeBtn" class="btn secondary">Enter Calibrate Mode</button>
          <button id="resetCalBtn" class="btn secondary">Reset</button>
        </div>
        <div style="margin-top:8px">
          <label class="small">Pixels per mm (stored at zoom=1):</label>
          <div id="pxPerMm" style="font-weight:700">—</div>
          <label class="small">True Magnification:</label>
          <div id="trueMag" style="font-weight:700">—</div>
        </div>
      </div>

      <div class="panel">
        <div class="small"><strong>Measurement</strong></div>
        <div class="small" style="margin-top:6px">Click two points across crack to measure width. Drag points to refine.</div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="measureModeBtn" class="btn">Measure</button>
          <button id="saveMeasureBtn" class="btn secondary">Save</button>
        </div>
        <div style="margin-top:8px">
          <label class="small">Saved Measurements (mm)</label>
          <div id="measureList" class="measure-list"></div>
        </div>
      </div>

      <div class="footer">v2.1 — 1 mm live scale (white)</div>
    </aside>
  </div>
</div>

<script>
(async function(){
  const video = document.getElementById('video'),
        overlay = document.getElementById('overlay'),
        frozenCanvas = document.getElementById('frozenFrame'),
        ctx = overlay.getContext('2d'),
        frozenCtx = frozenCanvas.getContext('2d');

  const freezeBtn = document.getElementById('freezeBtn'),
        zoomRange = document.getElementById('zoomRange'),
        zoomDisplay = document.getElementById('zoomDisplay'),
        trueMagEl = document.getElementById('trueMag'),
        pxPerMmEl = document.getElementById('pxPerMm'),
        calModeBtn = document.getElementById('calModeBtn'),
        resetCalBtn = document.getElementById('resetCalBtn'),
        measureModeBtn = document.getElementById('measureModeBtn'),
        saveMeasureBtn = document.getElementById('saveMeasureBtn'),
        clearBtn = document.getElementById('clearBtn'),
        captureBtn = document.getElementById('captureBtn'),
        exportBtn = document.getElementById('exportBtn'),
        zoomOutBtn = document.getElementById('zoomOutBtn'),
        zoomInBtn = document.getElementById('zoomInBtn'),
        measureListEl = document.getElementById('measureList'),
        liveReadout = document.getElementById('liveReadout');

  let stream = null, isFrozen = false, currentMode = null;
  // calibration.pxPerMm is stored as "pixels per mm at zoom = 1"
  let calibration = { pixels: null, mm: null, pxPerMm: null };
  let points = [], saved = [], trueMag = 1;

  function fitCanvas(){
    const w = overlay.clientWidth, h = overlay.clientHeight;
    [overlay, frozenCanvas].forEach(c => { c.width = w; c.height = h; });
  }

  async function startCamera(){
    try {
      if (stream) stream.getTracks().forEach(t => t.stop());
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 960 } },
        audio: false
      });
      video.srcObject = stream;
      video.muted = true;
      video.setAttribute('playsinline', true);
      video.addEventListener('loadedmetadata', () => {
        fitCanvas();
        console.log('Camera feed loaded', video.videoWidth, 'x', video.videoHeight);
      });
      await video.play();
    } catch (err){
      console.error('Camera access error:', err);
      alert('Camera access blocked or unavailable. Please allow camera permissions.');
    }
  }

  await startCamera();
  window.addEventListener('resize', fitCanvas);

  // zoom controls
  zoomRange.addEventListener('input', updateZoom);
  zoomOutBtn.onclick = () => { zoomRange.value = Math.max(1, Number(zoomRange.value) - 0.5); updateZoom(); };
  zoomInBtn.onclick = () => { zoomRange.value = Math.min(64, Number(zoomRange.value) + 0.5); updateZoom(); };

  function updateZoom(){
    const z = Number(zoomRange.value);
    video.style.transform = `scale(${z})`;
    frozenCanvas.style.transform = `scale(${z})`;
    zoomDisplay.textContent = z.toFixed(1) + '×';
    updateMagnification();
  }

  function updateMagnification(){
    if(!calibration.pxPerMm){ trueMagEl.textContent='—'; trueMag = Number(zoomRange.value); return; }
    const screenPPI = window.devicePixelRatio * 96;
    const screenPxPerMm = screenPPI / 25.4;
    trueMag = (calibration.pxPerMm / screenPxPerMm) * Number(zoomRange.value);
    trueMagEl.textContent = trueMag.toFixed(1) + '×';
  }

  // pointer -> canvas coordinates
  function clientToCanvas(e){
    const r = overlay.getBoundingClientRect();
    const x = ((e.touches ? e.touches[0].clientX : e.clientX) - r.left) * (overlay.width / r.width);
    const y = ((e.touches ? e.touches[0].clientY : e.clientY) - r.top) * (overlay.height / r.height);
    return { x, y };
  }

  let dragging = null;
  overlay.addEventListener('pointerdown', e => {
    overlay.setPointerCapture(e.pointerId);
    const p = clientToCanvas(e);
    for(const pt of points){
      if(Math.hypot(pt.x-p.x, pt.y-p.y) < 12){ dragging = pt; return; }
    }
    if(currentMode === 'calibrate'){
      points.push({ x: p.x, y: p.y, type: 'cal' });
      const c = points.filter(pt => pt.type === 'cal');
      if(c.length === 2){
        const dx = c[0].x - c[1].x, dy = c[0].y - c[1].y, pix = Math.hypot(dx, dy);
        const real = prompt('Enter real distance (mm):');
        if(real && !isNaN(real) && Number(real) > 0){
          const zoom = Number(zoomRange.value);
          // store pxPerMm at zoom=1
          calibration = { pixels: pix/zoom, mm: Number(real), pxPerMm: (pix/Number(real))/zoom };
          pxPerMmEl.textContent = calibration.pxPerMm.toFixed(4) + ' px/mm';
          updateMagnification();
          video.play().catch(()=>{});
        } else alert('Invalid input');
        currentMode = null; calModeBtn.textContent = 'Enter Calibrate Mode';
        // clear cal points
        points = points.filter(p=>p.type!=='cal');
      }
    } else if(currentMode === 'measure'){
      points.push({ x: p.x, y: p.y, type: 'meas' });
      const m = points.filter(pt => pt.type === 'meas');
      if(m.length === 2){
        currentMode = null; measureModeBtn.textContent = 'Measure';
      }
    }
    draw();
  });

  overlay.addEventListener('pointermove', e => {
    if(!dragging) return;
    const p = clientToCanvas(e);
    dragging.x = p.x; dragging.y = p.y;
    draw();
  });

  overlay.addEventListener('pointerup', ()=> dragging = null);

  calModeBtn.onclick = () => { currentMode = currentMode === 'calibrate' ? null : 'calibrate'; calModeBtn.textContent = currentMode ? 'Exit Calibrate Mode' : 'Enter Calibrate Mode'; };
  measureModeBtn.onclick = () => { currentMode = currentMode === 'measure' ? null : 'measure'; measureModeBtn.textContent = currentMode ? 'Exit Measure Mode' : 'Measure'; };
  resetCalBtn.onclick = () => { calibration = { pixels:null, mm:null, pxPerMm:null }; pxPerMmEl.textContent = '—'; trueMagEl.textContent = '—'; draw(); };
  clearBtn.onclick = () => { points = []; liveReadout.textContent = 'No measurement'; draw(); };

  saveMeasureBtn.onclick = () => {
    const m = points.filter(p=>p.type==='meas');
    if(m.length < 2) return alert('Place two points');
    if(!calibration.pxPerMm) return alert('Calibrate first');
    const pix = Math.hypot(m[0].x - m[1].x, m[0].y - m[1].y);
    const z = Number(zoomRange.value);
    const mm = (pix / z) / calibration.pxPerMm;
    saved.push({ time: new Date().toISOString(), mm, mag: trueMag });
    updateList();
  };

  function updateList(){
    measureListEl.innerHTML = '';
    saved.forEach((m,i) => {
      const d = document.createElement('div');
      d.textContent = `${i+1}. ${m.mm.toFixed(3)} mm @ ${m.mag.toFixed(1)}× — ${m.time}`;
      measureListEl.appendChild(d);
    });
  }

  // capture — uses fixed 4:3 base resolution to avoid distortion
  captureBtn.onclick = () => {
    const baseW = 1280, baseH = 960;
    const c = document.createElement('canvas'); c.width = baseW; c.height = baseH;
    const cx = c.getContext('2d');
    const videoRatio = video.videoWidth / video.videoHeight;
    const targetRatio = baseW / baseH;
    let sx, sy, sw, sh;
    if(videoRatio > targetRatio){ sh = video.videoHeight; sw = sh * targetRatio; sx = (video.videoWidth - sw)/2; sy = 0; }
    else { sw = video.videoWidth; sh = sw / targetRatio; sx = 0; sy = (video.videoHeight - sh)/2; }
    // temporarily remove transforms for iPhone capture
    const prevTransformVideo = video.style.transform;
    const prevTransformFrozen = frozenCanvas.style.transform;
    video.style.transform = "none";
    frozenCanvas.style.transform = "none";

    // force reflow
    void video.offsetHeight;

    cx.drawImage(isFrozen ? frozenCanvas : video, sx, sy, sw, sh, 0, 0, baseW, baseH);

    // restore zoom transform
    video.style.transform = prevTransformVideo;
    frozenCanvas.style.transform = prevTransformFrozen;

    // draw overlay scaled to capture size
    cx.drawImage(overlay, 0, 0, baseW, baseH);
    const timestamp = new Date().toISOString().replace(/[:.]/g,'-');
    const link = document.createElement('a'); link.download = `Microscope_${timestamp}.png`; link.href = c.toDataURL('image/png'); link.click();
  };

  exportBtn.onclick = () => {
    if(!saved.length) return alert('No data');
    const csv = 'timestamp,mm,magnification\n' + saved.map(r=>`${r.time},${r.mm.toFixed(4)},${r.mag.toFixed(1)}`).join('\n');
    const blob = new Blob([csv],{type:'text/csv'}); const a = document.createElement('a');
    a.href = URL.createObjectURL(blob); a.download = 'measurements.csv'; a.click();
  };

  // draw overlay contents
  function draw(){
    ctx.clearRect(0,0,overlay.width,overlay.height);

    // draw calibration & measurement cross markers
    for(let i=0;i<points.length;i++){
      const p = points[i];
      const color = p.type === 'cal' ? '#ffb020' : '#06b6d4';
      drawCross(p.x,p.y,6,color,2);
      if(i%2===1 && points[i-1]){
        const a = points[i-1], b = points[i];
        const dx = a.x - b.x, dy = a.y - b.y, pix = Math.hypot(dx,dy);
        const z = Number(zoomRange.value);
        const mm = (calibration.pxPerMm ? (pix / z) / calibration.pxPerMm : null);
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
        ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = '#e6eef6'; ctx.font = '13px sans-serif';
        ctx.fillText(mm ? mm.toFixed(3)+' mm' : Math.round(pix)+' px', (a.x+b.x)/2 + 8, (a.y+b.y)/2 - 8);
      }
    }

    // crosshair center
    const cx = overlay.width/2, cy = overlay.height/2;
    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(overlay.width, cy); ctx.moveTo(cx, 0); ctx.lineTo(cx, overlay.height); ctx.stroke();

    // ticks along center lines
    const tickSpacing = 10, tickLen = 4;
    ctx.beginPath();
    for(let x=0;x<overlay.width;x+=tickSpacing){ ctx.moveTo(x, cy - tickLen); ctx.lineTo(x, cy + tickLen); }
    for(let y=0;y<overlay.height;y+=tickSpacing){ ctx.moveTo(cx - tickLen, y); ctx.lineTo(cx + tickLen, y); }
    ctx.stroke();

    // white 1 mm live scale bar at bottom-left (if calibrated)
    if(calibration.pxPerMm){
      const barMm = 1;
      const z = Number(zoomRange.value);
      const barPx = calibration.pxPerMm * barMm * z; // displayed pixels
      const margin = 14;
      const x1 = margin, x2 = Math.min(x1 + barPx, overlay.width - margin);
      const y = overlay.height - margin;
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
      ctx.fillStyle = '#ffffff'; ctx.font = '12px sans-serif'; ctx.textAlign = 'left';
      ctx.fillText(`${barMm} mm`, x2 + 8, y + 4);
      // small end ticks
      ctx.beginPath(); ctx.moveTo(x1, y-6); ctx.lineTo(x1, y+6); ctx.moveTo(x2, y-6); ctx.lineTo(x2, y+6); ctx.stroke();
    }

    // date/time and zoom overlay (top-right)
    const now = new Date(), dateStr = now.toLocaleDateString(), timeStr = now.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    const zoomText = `${trueMag.toFixed(1)}×`;
    ctx.fillStyle = '#fff'; ctx.font = '12px monospace'; ctx.textAlign = 'right';
    ctx.fillText(`${dateStr} ${timeStr}`, overlay.width - 10, 18);
    ctx.fillText(`Zoom: ${zoomText}`, overlay.width - 10, 34);

    // live numeric readout for measurement (if two measurement points present)
    const meas = points.filter(p=>p.type==='meas');
    if(meas.length === 2 && calibration.pxPerMm){
      const pix = Math.hypot(meas[0].x - meas[1].x, meas[0].y - meas[1].y);
      const z = Number(zoomRange.value);
      const mm = (pix / z) / calibration.pxPerMm;
      liveReadout.textContent = mm.toFixed(3) + ' mm';
    } else if(meas.length === 1){
      liveReadout.textContent = 'Place second point';
    } else {
      liveReadout.textContent = 'No measurement';
    }
  }

  function drawCross(x,y,size,color,lineW){
    ctx.strokeStyle = color; ctx.lineWidth = lineW;
    ctx.beginPath();
    ctx.moveTo(x - size, y - size); ctx.lineTo(x + size, y + size);
    ctx.moveTo(x - size, y + size); ctx.lineTo(x + size, y - size);
    ctx.stroke();
  }

  requestAnimationFrame(function loop(){ draw(); requestAnimationFrame(loop); });

})();
</script>
</body>
</html>
