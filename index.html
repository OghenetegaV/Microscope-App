<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Microscope + Measurement (v2.2 — Fixed 4:3)</title>
<style>
:root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#071024 0%,#07192b 100%);color:#e6eef6}
.app{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;min-height:100vh;width:100%;max-width:1000px;margin:0 auto;padding:10px;box-sizing:border-box;background:var(--card);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
header{display:flex;align-items:center;gap:12px;width:100%}
h1{font-size:18px;margin:0}
.grid{display:grid;grid-template-columns:1fr 360px;gap:12px;margin-top:12px;width:100%}
@media (max-width:900px){.grid{grid-template-columns:1fr}}
.viewer{position:relative;width:100%;background:#000;border-radius:10px;overflow:hidden;aspect-ratio:4/3;max-height:80vh;min-height:320px}
.video-box{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
video,canvas#frozenFrame,canvas.overlay{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}
video{z-index:0;background:#000}
canvas.overlay,canvas#frozenFrame{z-index:1;background:transparent}
.controls{display:flex;flex-direction:column;gap:10px;width:100%;margin-top:10px}
.panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px}
.btn{background:var(--accent);color:#062024;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
.measure-list{max-height:200px;overflow:auto;padding:6px;font-size:13px;border-radius:6px;background:rgba(0,0,0,0.15)}
.small{font-size:12px;color:var(--muted)}
.footer{font-size:12px;color:var(--muted);margin-top:8px}
.measure-readout{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:6px;font-family:monospace;color:#fff;z-index:3}
.start-camera{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:4}
@media (max-width:768px){.viewer{height:60vh;aspect-ratio:auto}.app{padding:5px}.controls{gap:6px}}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Microscope + Measurement — Fixed 4:3</h1>
    <div style="margin-left:auto" class="small">Freeze for stable calibration</div>
  </header>

  <div class="grid">
    <div>
      <div class="viewer" id="viewer">
        <div class="measure-readout" id="liveReadout">No measurement</div>
        <div class="video-box">
          <video id="video" playsinline muted></video>
          <canvas id="frozenFrame"></canvas>
          <canvas id="overlay" class="overlay"></canvas>
          <button id="startCameraBtn" class="btn start-camera" style="display:none">Start Camera</button>
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <button id="freezeBtn" class="btn">Freeze</button>
        <button id="captureBtn" class="btn">Capture</button>
        <button id="clearBtn" class="btn secondary">Clear</button>
        <button id="exportBtn" class="btn secondary">Export CSV</button>
      </div>

      <div class="panel" style="margin-top:8px">
        <div class="small">Digital Zoom (digital crop)</div>
        <div style="display:flex;align-items:center;gap:6px;">
          <button id="zoomOutBtn" class="btn secondary" style="width:36px;">−</button>
          <input id="zoomRange" type="range" min="1" max="16" step="0.1" value="1" style="flex:1;">
          <button id="zoomInBtn" class="btn secondary" style="width:36px;">+</button>
        </div>
        <div class="small">Current Zoom: <span id="zoomDisplay">1×</span></div>
      </div>
    </div>

    <aside class="controls">
      <div class="panel">
        <div class="small"><strong>Calibration</strong></div>
        <div class="small" style="margin-top:6px">Click two points on a known-length reference (e.g. 10 mm), then enter distance (mm).</div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="calModeBtn" class="btn secondary">Enter Calibrate Mode</button>
          <button id="resetCalBtn" class="btn secondary">Reset</button>
        </div>
        <div style="margin-top:8px">
          <label class="small">Pixels per mm (stored at zoom=1):</label>
          <div id="pxPerMm" style="font-weight:700">—</div>
          <label class="small">True Magnification:</label>
          <div id="trueMag" style="font-weight:700">—</div>
        </div>
      </div>

      <div class="panel">
        <div class="small"><strong>Measurement</strong></div>
        <div class="small" style="margin-top:6px">Click two points across crack to measure width. Drag points to refine.</div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="measureModeBtn" class="btn">Measure</button>
          <button id="saveMeasureBtn" class="btn secondary">Save</button>
        </div>
        <div style="margin-top:8px">
          <label class="small">Saved Measurements (mm)</label>
          <div id="measureList" class="measure-list"></div>
        </div>
      </div>

      <div class="footer">v2.2 — Fixed 4:3 scientific viewport</div>
    </aside>
  </div>
</div>

<script>
(async function(){
  const video = document.getElementById('video'),
        overlay = document.getElementById('overlay'),
        frozenCanvas = document.getElementById('frozenFrame'),
        viewer = document.getElementById('viewer'),
        startCameraBtn = document.getElementById('startCameraBtn'),
        ctx = overlay.getContext('2d'),
        frozenCtx = frozenCanvas.getContext('2d');

  const freezeBtn = document.getElementById('freezeBtn'),
        captureBtn = document.getElementById('captureBtn'),
        clearBtn = document.getElementById('clearBtn'),
        exportBtn = document.getElementById('exportBtn'),
        zoomRange = document.getElementById('zoomRange'),
        zoomDisplay = document.getElementById('zoomDisplay'),
        zoomOutBtn = document.getElementById('zoomOutBtn'),
        zoomInBtn = document.getElementById('zoomInBtn'),
        calModeBtn = document.getElementById('calModeBtn'),
        resetCalBtn = document.getElementById('resetCalBtn'),
        measureModeBtn = document.getElementById('measureModeBtn'),
        saveMeasureBtn = document.getElementById('saveMeasureBtn'),
        pxPerMmEl = document.getElementById('pxPerMm'),
        trueMagEl = document.getElementById('trueMag'),
        liveReadout = document.getElementById('liveReadout'),
        measureListEl = document.getElementById('measureList');

  let stream = null, isFrozen = false, currentMode = null;
  let calibration = { pixels:null, mm:null, pxPerMm:null }; // px/mm at zoom=1
  let points = [], saved = [], trueMag = 1;
  let zoom = 1; // digital crop factor
  window.addEventListener('resize', fitCanvas);

  function fitCanvas(){
    const w = overlay.clientWidth, h = overlay.clientHeight;
    [overlay, frozenCanvas].forEach(c => { c.width = w; c.height = h; });
  }

  async function initStream(){
    try{
      if(stream) stream.getTracks().forEach(t=>t.stop());
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio:false });
      video.srcObject = stream;
      video.setAttribute('playsinline', true);
      video.muted = true;
      video.addEventListener('loadedmetadata', ()=>{ fitCanvas(); startCameraBtn.style.display = 'none'; });
      await video.play();
      fitCanvas();
    }catch(err){
      console.warn('Camera start failed:', err);
      startCameraBtn.style.display = 'block';
    }
  }

  startCameraBtn.onclick = async ()=>{ startCameraBtn.textContent='Starting...'; await initStream(); startCameraBtn.remove(); };

  await initStream();

  // compute visible crop (object-fit:cover) then apply zoom crop
  function computeVideoCrop(){
    const vw = video.videoWidth, vh = video.videoHeight;
    const elW = video.clientWidth, elH = video.clientHeight;
    if(!vw||!vh) return {sx:0,sy:0,sw:vw,sh:vh};
    const videoRatio = vw / vh, boxRatio = elW / elH;
    let sx, sy, sw, sh;
    if(videoRatio > boxRatio){
      sh = vh; sw = sh * boxRatio; sx = (vw - sw) / 2; sy = 0;
    } else {
      sw = vw; sh = sw / boxRatio; sx = 0; sy = (vh - sh) / 2;
    }
    // apply zoom (crop further centered)
    const swZoom = sw / zoom, shZoom = sh / zoom;
    const sxZoom = sx + (sw - swZoom)/2, syZoom = sy + (sh - shZoom)/2;
    return { sx: sxZoom, sy: syZoom, sw: swZoom, sh: shZoom };
  }

  function updateZoom(){
    zoom = Number(zoomRange.value);
    zoomDisplay.textContent = zoom.toFixed(1) + '×';
    updateMagnification();
    draw(); // refresh overlay (scale bar depends on zoom)
  }
  zoomRange.addEventListener('input', updateZoom);
  zoomOutBtn.onclick = ()=>{ zoomRange.value = Math.max(1, Number(zoomRange.value)-0.5); updateZoom(); };
  zoomInBtn.onclick = ()=>{ zoomRange.value = Math.min(16, Number(zoomRange.value)+0.5); updateZoom(); };

  function updateMagnification(){
    if(!calibration.pxPerMm){ trueMagEl.textContent='—'; trueMag = Number(zoom); return; }
    const screenPPI = window.devicePixelRatio * 96;
    const screenPxPerMm = screenPPI / 25.4;
    trueMag = (calibration.pxPerMm / screenPxPerMm) * Number(zoom);
    trueMagEl.textContent = trueMag.toFixed(1) + '×';
  }

  // drawing helpers
  function drawCross(x,y,size,color,lineW){ ctx.strokeStyle=color; ctx.lineWidth=lineW; ctx.beginPath(); ctx.moveTo(x-size,y-size); ctx.lineTo(x+size,y+size); ctx.moveTo(x-size,y+size); ctx.lineTo(x+size,y-size); ctx.stroke(); }

  // pointer -> overlay coords
  function clientToCanvas(e){
    const r = overlay.getBoundingClientRect();
    const x = ((e.touches ? e.touches[0].clientX : e.clientX) - r.left) * (overlay.width / r.width);
    const y = ((e.touches ? e.touches[0].clientY : e.clientY) - r.top) * (overlay.height / r.height);
    return { x, y };
  }

  let dragging = null;
  overlay.addEventListener('pointerdown', e=>{
    overlay.setPointerCapture(e.pointerId);
    const p = clientToCanvas(e);
    for(const pt of points){ if(Math.hypot(pt.x - p.x, pt.y - p.y) < 14){ dragging = pt; return; } }
    if(currentMode === 'calibrate'){
      points.push({ x:p.x, y:p.y, type:'cal' });
      const c = points.filter(pt=>pt.type==='cal');
      if(c.length===2){
        const dx = c[0].x - c[1].x, dy = c[0].y - c[1].y, pixDisplay = Math.hypot(dx,dy);
        const real = prompt('Enter real distance (mm):');
        if(real && !isNaN(real) && Number(real)>0){
          // store pxPerMm at zoom=1
          calibration = { pixels: (pixDisplay / zoom), mm: Number(real), pxPerMm: (pixDisplay/Number(real))/zoom };
          pxPerMmEl.textContent = calibration.pxPerMm.toFixed(4) + ' px/mm';
          updateMagnification();
          video.play().catch(()=>{});
        } else alert('Invalid input');
        currentMode = null; calModeBtn.textContent = 'Enter Calibrate Mode';
        points = points.filter(p=>p.type!=='cal');
      }
    } else if(currentMode === 'measure'){
      points.push({ x:p.x, y:p.y, type:'meas' });
      const m = points.filter(pt=>pt.type==='meas');
      if(m.length===2){ currentMode = null; measureModeBtn.textContent = 'Measure'; }
    }
    draw();
  });

  overlay.addEventListener('pointermove', e=>{ if(!dragging) return; const p=clientToCanvas(e); dragging.x=p.x; dragging.y=p.y; draw(); });
  overlay.addEventListener('pointerup', ()=> dragging=null );

  calModeBtn.onclick = ()=>{ currentMode = currentMode==='calibrate'?null:'calibrate'; calModeBtn.textContent = currentMode? 'Exit Calibrate Mode':'Enter Calibrate Mode'; };
  measureModeBtn.onclick = ()=>{ currentMode = currentMode==='measure'?null:'measure'; measureModeBtn.textContent = currentMode? 'Exit Measure Mode':'Measure'; };
  resetCalBtn.onclick = ()=>{ calibration = { pixels:null, mm:null, pxPerMm:null }; pxPerMmEl.textContent='—'; trueMagEl.textContent='—'; draw(); };
  clearBtn.onclick = ()=>{ points = []; liveReadout.textContent='No measurement'; draw(); };

  saveMeasureBtn.onclick = ()=>{
    const m = points.filter(p=>p.type==='meas');
    if(m.length<2) return alert('Place two points');
    if(!calibration.pxPerMm) return alert('Calibrate first');
    const pixDisplay = Math.hypot(m[0].x - m[1].x, m[0].y - m[1].y);
    const mm = (pixDisplay / zoom) / calibration.pxPerMm;
    saved.push({ time:new Date().toISOString(), mm, mag:trueMag });
    updateList();
  };

  function updateList(){ measureListEl.innerHTML=''; saved.forEach((r,i)=>{ const d=document.createElement('div'); d.textContent=`${i+1}. ${r.mm.toFixed(3)} mm @ ${r.mag.toFixed(1)}× — ${r.time}`; measureListEl.appendChild(d); }); }

  // Freeze logic: draw visible crop to frozenCanvas (pixel-perfect)
  freezeBtn.onclick = ()=>{
    if(!isFrozen){
      fitCanvas();
      const crop = computeVideoCrop();
      frozenCtx.clearRect(0,0,frozenCanvas.width,frozenCanvas.height);
      frozenCtx.drawImage(video, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, frozenCanvas.width, frozenCanvas.height);
      frozenCanvas.style.display='block'; video.style.display='none'; isFrozen = true; freezeBtn.textContent='Unfreeze';
    } else {
      frozenCanvas.style.display='none'; video.style.display='block'; isFrozen=false; freezeBtn.textContent='Freeze';
    }
  };

  // Capture: draw zoomed crop (same method used for freeze) then overlay; works on iPhone
  captureBtn.onclick = ()=>{
    const baseW = 2048, baseH = 1536; // high-res 4:3 base
    const c = document.createElement('canvas'); c.width = baseW; c.height = baseH;
    const cx = c.getContext('2d');
    const crop = computeVideoCrop();
    // draw actual video pixels for crop -> avoid CSS transforms
    cx.drawImage(video, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, baseW, baseH);
    // draw overlay scaled to capture resolution
    cx.drawImage(overlay, 0, 0, baseW, baseH);
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    const link = document.createElement('a'); link.download=`Microscope_${ts}.png`; link.href=c.toDataURL('image/png'); link.click();
  };

  exportBtn.onclick = ()=>{
    if(!saved.length) return alert('No data');
    const csv = 'timestamp,mm,magnification\n' + saved.map(r=>`${r.time},${r.mm.toFixed(4)},${r.mag.toFixed(1)}`).join('\n');
    const blob = new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='measurements.csv'; a.click();
  };

  // main overlay draw
  function draw(){
    ctx.clearRect(0,0,overlay.width,overlay.height);

    // calibration & measurement crosses
    for(let i=0;i<points.length;i++){
      const p = points[i], color = p.type==='cal'?'#ffb020':'#06b6d4';
      drawCross(p.x,p.y,7,color,2);
      if(i%2===1 && points[i-1]){
        const a=points[i-1], b=points[i], pix = Math.hypot(a.x-b.x,a.y-b.y);
        const mm = calibration.pxPerMm ? (pix/zoom)/calibration.pxPerMm : null;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
        ctx.fillStyle='#e6eef6'; ctx.font='13px sans-serif'; ctx.fillText(mm?mm.toFixed(3)+' mm':Math.round(pix)+' px',(a.x+b.x)/2+8,(a.y+b.y)/2-8);
      }
    }

    // central crosshair & ticks
    const cx = overlay.width/2, cy = overlay.height/2;
    ctx.strokeStyle='rgba(255,255,255,0.45)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(overlay.width,cy); ctx.moveTo(cx,0); ctx.lineTo(cx,overlay.height); ctx.stroke();
    const tick=10, tlen=4; ctx.beginPath();
    for(let x=0;x<overlay.width;x+=tick){ ctx.moveTo(x,cy-tlen); ctx.lineTo(x,cy+tlen); }
    for(let y=0;y<overlay.height;y+=tick){ ctx.moveTo(cx-tlen,y); ctx.lineTo(cx+tlen,y); }
    ctx.stroke();

    // 1 mm white scale bar (bottom-left)
    if(calibration.pxPerMm){
      const barMm = 1;
      const barPx = calibration.pxPerMm * barMm * zoom;
      const margin = 14;
      const x1 = margin, x2 = Math.min(x1 + barPx, overlay.width - margin);
      const y = overlay.height - margin;
      ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x1,y); ctx.lineTo(x2,y); ctx.stroke();
      ctx.fillStyle='#fff'; ctx.font='12px sans-serif'; ctx.textAlign='left'; ctx.fillText(`${barMm} mm`, x2 + 8, y + 4);
      ctx.beginPath(); ctx.moveTo(x1,y-6); ctx.lineTo(x1,y+6); ctx.moveTo(x2,y-6); ctx.lineTo(x2,y+6); ctx.stroke();
    }

    // date/time and zoom (top-right)
    const now = new Date(), dateStr = now.toLocaleDateString(), timeStr = now.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.textAlign='right'; ctx.fillText(`${dateStr} ${timeStr}`, overlay.width-10, 18);
    ctx.fillText(`Zoom: ${zoom.toFixed(1)}×`, overlay.width-10, 34);

    // live numeric readout
    const meas = points.filter(p=>p.type==='meas');
    if(meas.length===2 && calibration.pxPerMm){
      const pix = Math.hypot(meas[0].x - meas[1].x, meas[0].y - meas[1].y);
      const mm = (pix / zoom) / calibration.pxPerMm;
      liveReadout.textContent = mm.toFixed(3) + ' mm';
    } else if(meas.length===1) liveReadout.textContent = 'Place second point'; else liveReadout.textContent='No measurement';
  }

  // computeVideoCrop used inline when capturing/freezing

  // start animation
  requestAnimationFrame(function loop(){ draw(); requestAnimationFrame(loop); });

})();
</script>
</body>
</html>
